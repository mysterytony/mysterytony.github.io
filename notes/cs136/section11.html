<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>section11</title></head><body><article class="markdown-body"><p><a href="http://tonyli.tk/">&lt;- Go Back</a></p>
<h2 id="section-11-linked-data-structures"><a name="user-content-section-11-linked-data-structures" href="#section-11-linked-data-structures" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Section 11: Linked Data Structures</h2>
<h4 id="linked-lists"><a name="user-content-linked-lists" href="#linked-lists" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Linked lists</h4>
<p>Racket&rsquo;s like type is more commonly known as a <strong>linked list</strong></p>
<p><img alt="linked list" src="http://tonyli.tk/notes/cs136/sec11pg2.PNG" /></p>
<p>Each <strong>node</strong> contains an <strong>item</strong> and a <strong>link</strong> (pointer) to the <strong>next</strong> node in the list.</p>
<p>The last node&rsquo;s link contains a special <strong>sentinel value</strong> to indicate it is the last node.</p>
<p>A linked list is usually represent as a link to the <strong>front</strong> of the list.</p>
<p><img alt="linked list front" src="http://tonyli.tk/notes/cs136/sec11pg3.PNG" /></p>
<p>Unlike arrays, linked list nodes are not arranged sequentially in memory. In general, there is no convenient way to &ldquo;jump&rdquo; to the $i$-th element in a linked list. The linked list must be <strong>traversed</strong> from the front. Traversing a linked list is $O(n)$.</p>
<p>A significant advantage of a linked list is that its length can easily change, and the length does not need to be known in advance.</p>
<p>The memory for each node is allocated dynamically.</p>
<h4 id="functional-vs-imperative-approach"><a name="user-content-functional-vs-imperative-approach" href="#functional-vs-imperative-approach" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Functional vs. Imperative approach</h4>
<p>The core concept of a linked list data structure is independent of any single paradigm.</p>
<p>However, the approach used to <strong>implement</strong> and write functions that process linked lists are very different.</p>
<p>Programming with linked lists further illustrates the differences between the two paradigms.</p>
<h4 id="dynamic-memory-in-racket"><a name="user-content-dynamic-memory-in-racket" href="#dynamic-memory-in-racket" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Dynamic memory in Racket</h4>
<p>Racket uses dynamic memory, but it is mostly <em>hidden</em> from the programmer.</p>
<p>The <code>cons</code> function dynamically creates a <strong>new</strong> linked list node.</p>
<p>The <code>list</code> function and quote list notation <code>'(1 2 3)</code> implicitly use <code>cons</code>.</p>
<p>The only other method of using dynamic memory in Racket is the constructor to <code>make</code> a <strong>new</strong> structure.</p>
<p>Knowing how <code>cons</code> uses dynamic memory, consider how the following Racket function <code>sqr-list</code> constructs a <strong>new list</strong></p>
<pre><code class="Racket">(define (sqr-list lst)
(cond   [(empty? lst) empty]
[else (cons (sqr (first lst) (sqr-list (rest lst))))]))

(define a '(10 3 5 7))
(define b (sqr-list a))
</code></pre>

<p><img alt="linked list racket" src="http://tonyli.tk/notes/cs136/sec11pg7.PNG" /></p>
<p>In the functional programming paradigm, this is the only sensical meaning, because there is no mutation.</p>
<p>In the imperative programming paradigm, a &ldquo;square list&rdquo; function is more likely to <strong>mutate</strong> an existing list instead of producing a new list.</p>
<blockquote>
<p>In practice, most imperative list functions perform mutation. If the caller wants a new list (instead of mutating an existing one), they can first make a copy of the original list and then mutate the new copy.</p>
</blockquote>
<h4 id="mixing-paradigms"><a name="user-content-mixing-paradigms" href="#mixing-paradigms" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Mixing paradigms</h4>
<p>Problems may arise if we naively use the functional paradigm in an imperative environment without considering the consequences.</p>
<p>This is especially important in C, where there is no garbage collector.</p>
<table>
<thead>
<tr>
<th>Functional (Racket)</th>
<th>Imperative (C)</th>
</tr>
</thead>
<tbody>
<tr>
<td>no mutation</td>
<td>mutation</td>
</tr>
<tr>
<td>garbage collector</td>
<td>no garbage collector</td>
</tr>
<tr>
<td>hidden pointers</td>
<td>explicit pointers</td>
</tr>
</tbody>
</table>
<p>The following example highlights the potential problems.</p>
<p>Recall the <code>insert</code> function used in Racket&rsquo;s <code>insertion sort</code>.</p>
<pre><code class="Racket">;; (insert n slon) inserts n into a sorted list of numbers
(define (insert n slon)
(cons   [(empty? slon) (cons n empty)]
[(&lt;= n (first slon)) (cons n slon)]
[else (cons (first slon) (insert n (rest slon)))]))

(define a '(10 20 50 100))
(define b (insert 30 a))
</code></pre>

<p><img alt="racket insert linked list" src="http://tonyli.tk/notes/cs136/sec11pg10.PNG" /></p>
<p>The lists <strong>share the last two nodes</strong></p>
<p>In Racket this behavior is completely transparent because there is <strong>no mutation</strong>, and there is ad <strong>garbage collector</strong>.</p>
<p>In an imperative language like C, this configuration is problematic.<br />
<em>   If we apply a mutative function such as &ldquo;square list&rdquo; on <code>a</code>, then some of the elements of <code>b</code> will unexpectedly change.<br />
</em>   If we explicitly <code>free</code> all of the memory for list <code>a</code>, then list <code>b</code>will become invalid.</p>
<p>List functions that perform computations and do not modify the list (or produce a new list) work well in both paradigms.</p>
<p>If a function mutates a list (or produces a &ldquo;new&rdquo; list), you should use caution to ensure that the result will not create further problems.</p>
<blockquote>
<p>In Racket, lists are immutable, and there is a special <code>mcons</code> function to generate a mutable list.<br />
In the Scheme language, lists are mutable. This is one of the significant differences between Racket and Scheme.</p>
</blockquote>
<h4 id="linked-lists-in-c"><a name="user-content-linked-lists-in-c" href="#linked-lists-in-c" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Linked lists in C</h4>
<p>There is no &ldquo;official&rdquo; way of implementing a linked list in C.</p>
<p>In this section we present a typical linked list structure that uses a <strong>wrapper</strong> strategy.</p>
<p>First, we declare a <em>linked list node</em> (<code>llnode</code>) that stores an &ldquo;item&rdquo; and a link (pointer) to the next node.</p>
<pre><code class="C">struct llnode {
    int item;
    struct llnode *next;
};
</code></pre>

<p>A C structure can contain a <em>pointer</em> to its own structure type. This is the first <strong>recursive data structure</strong> we have seen in C.</p>
<p>For the last pointer in the list (or an empty list) we use a <code>NULL</code> pointer as a sentinel value.</p>
<p>As mentioned previously, we use a <strong>wrapper</strong> strategy, where we wrap the link to the first node inside of another structure (<code>llist</code>).</p>
<p>This makes some of the following code more straightforward.</p>
<pre><code class="C">struct llist {
    struct llnode *front;
}
</code></pre>

<p>We also define a <code>list_create</code> function to create an empty list.</p>
<pre><code class="C">struct llist *list_create(void) {
    struct llist *lst = malloc(sizeof(struct llist));
    list-&gt;front = NULL;
    return lst;
}
</code></pre>

<p>Of course, we need to add items to our linked list.</p>
<p>The following code creates a new node, and insert it at the front of the list.</p>
<pre><code class="C">void add_front(int i, struct llist *lst) {
    struct llnode *node = malloc(sizeof(struct llnode));
    node-&gt;item = i;
    node-&gt;next = lst-&gt;front;
    lst-&gt;front = node;
}
</code></pre>

<h4 id="traversing-a-list"><a name="user-content-traversing-a-list" href="#traversing-a-list" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Traversing a list</h4>
<p>We can traverse a list <strong>iteratively</strong> or <strong>recursively</strong>.</p>
<p>When iterating through a list, we typically use a (<code>llnode</code>) pointer to keep track of the &ldquo;current&rdquo; node.</p>
<pre><code class="C">int length(struct llist *lst) {
    int length = 0;
    struct llnode *node = lst-&gt;front;
    while (node) {
        ++length;
        node = node-&gt;next;
    }
    return length;
}
</code></pre>

<p>Remember (<code>node</code>) will be false at the end of the list (<code>NULL</code>)</p>
<p>When using <strong>recursion</strong>, remember to recurse on a node (<code>llnode</code>) not the wrapper list itself (<code>llist</code>).</p>
<pre><code class="C">int length_nodes(struct llnode *node) {
    if (node == NULL) return 0;
    return 1 + length_nodes(node-&gt;next);
}
</code></pre>

<p>You can write a corresponding wrapper function:</p>
<pre><code class="C">int list_length(struct llist *lst) {
    return length_nodes(lst-&gt;front);
}
</code></pre>

<p>or call the recursive function directly on the front of the list.</p>
<pre><code class="C">int len = length_nodes(lst-&gt;front);
</code></pre>

<h4 id="destroying-a-list"><a name="user-content-destroying-a-list" href="#destroying-a-list" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Destroying a list</h4>
<p>In C, we don&rsquo;t have a <em>garbage collector</em>, so we must be able to <code>free</code> our linked list. We need to free every node and the list wrapper.</p>
<p>When using an iterative approach, we are going to need two node pointers to ensure that the nodes are <code>freed</code> in a safe way.</p>
<pre><code class="C">void list_destroy(struct llist *lst) {
    struct llnode *curnode = lst-&gt;front;
    while (curnode) {
        struct llnode *nextnode = curnode-&gt;next;
        free(curnode);
        curnode = nextnode;
    }
    free(lst);
}
</code></pre>

<p>For more advanced list traversal functions, the technique of maintaining more than one node pointer is often necessary. It may take some practice and diagrams to master this technique.</p>
<p>For extra practice, consider this slightly different implementation:</p>
<pre><code class="C">void list_destroy(struct llist *lst) {
    struct llnode *curnode = lst-&gt;front;
    while (curnode) {
        struct llnode *backup = curnode;
        curnode = curnode-&gt;next;
        free(backup);
    }
    free(lst);
}
</code></pre>

<p>With a recursive approach, it is more convenient to free the rest of list before we <code>free</code> the first node.</p>
<pre><code class="C">void free_nodes(struct llnode *node) {
    if (node) {
        free_nodes(node-&gt;next);
        free(node);
    }
}

void list_destroy(struct llist *lst) {
    free_nodes(lst-&gt;front);
    free(lst);
}
</code></pre>

<h4 id="duplicating-a-list"><a name="user-content-duplicating-a-list" href="#duplicating-a-list" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Duplicating a list</h4>
<p>Previously, we used the &ldquo;square list&rdquo; function to illustrate the differences between the functional and imperative paradigms.</p>
<pre><code class="C">// list_sqr(lst) squares each item in lst
// effects: modifies lst

void list_sqr(struct llist *lst) {
    struct llnode *node = lst-&gt;front;
    while (node) {
        node-&gt;item *= node-&gt;item;
        node = node-&gt;next;
    }
}
</code></pre>

<p>But what if we do want a new list that is squared instead of mutating an existing one?</p>
<p>One solution is to provide a <code>list_dup</code> function, that makes a duplicate of an existing list.</p>
<p>The recursive function is the most straightforward.</p>
<pre><code class="C">void node_dup(struct llnode *node, struct llist *newlist) {
    if (node) {
        node_dup(node-&gt;next, newlist);
        add_front(node-&gt;item, newlist);
    }
}

struct llist *list_dup(struct llist *oldlist) {
    struct llist *newlist = list_create();
    node_dup(oldlist-&gt;front, newlist);
    return newlist;
}
</code></pre>

<p>The iterative solution is more complicated:</p>
<pre><code class="C">struct llist *list_dup(struct llist *oldlist) {
    struct llist *newlist = list_create();
    struct llnode *oldnode = oldlist-&gt;front;
    struct llnode *prevnode = NULL;
    while (oldnode) {
        struct llnode *newnode = malloc(sizeof(struct llnode));
        newnode-&gt;item = oldnode-&gt;item;
        newnode-&gt;next = NULL;
        if (prevnode) {
            prevnode-&gt;next = newnode;
        } else {
            newlist-&gt;front = newnode;
        }
        prevnode = newnode;
        oldnode = oldnode-&gt;next;
    }
    return newlist;
}
</code></pre>

<h4 id="imperative-insert"><a name="user-content-imperative-insert" href="#imperative-insert" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Imperative insert</h4>
<p>Earlier, we saw how the Racket (functional) implementation of insert would be problematic in C.</p>
<p>For an <code>insert</code> function in C, we expect the following behavior:</p>
<p><img alt="racket insert" src="http://tonyli.tk/notes/cs136/sec11pg26_1.PNG" /></p>
<pre><code class="C">insert( 5, a);
insert(30, a);
</code></pre>

<p><img alt="racket insert" src="http://tonyli.tk/notes/cs136/sec11pg26_2.PNG" /></p>
<pre><code class="C">// insert(i, slst) inserts i into list slst
// effects: modifies slst
// time: O(n), where n is the length of slst

void insert(int i, struct llist *slst) {
    if (slst-&gt;front == NULL || i &lt; slst-&gt;front-&gt;item) {
        add_front(i, slst);
    } else {
        struct llnode *prevnode = slst-&gt;front;
        while (prevnode-&gt;next &amp;&amp; i &gt; prevnode-&gt;next-&gt;item) {
            prevnode = prevnode-&gt;next;
        }
        struct llnode *newnode = malloc(sizeof(struct llnode));
        newnode-&gt;item = i;
        newnode-&gt;next = prevnode-&gt;next;
        prevnode-&gt;next = newnode;
    }
}
</code></pre>

<h4 id="removing-nodes"><a name="user-content-removing-nodes" href="#removing-nodes" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Removing nodes</h4>
<p>In Racket, the <code>rest</code> function does not actually remove the first element, instead it provides a pointer to the next node.</p>
<p>In C, we can implement a function that removes the first node.</p>
<pre><code class="C">int remove_front(struct llist *lst) {
    assert(lst-&gt;front);
    int retval = lst-&gt;front-&gt;item;
    struct llnode *backup = lst-&gt;front;
    lst-&gt;front = lst-&gt;front-&gt;next;
    free(backup);
    return retval;
}
</code></pre>

<p>Instead of returning nothing (<code>void</code>), it is more useful to return the value of the item being removed.</p>
<p>Removing a node from an arbitrary list position is more complicated.</p>
<pre><code class="C">// remove_item(i, lst) removes the first occurrence of i in lst
//   return value indicates if item is successfully removed

bool remove_item(int i, struct llist *lst) {
    if (lst-&gt;front == NULL) return false;
    if (lst-&gt;front-&gt;item == i) {
        remove_front(lst);
        return true;
    }
    struct llnode *prevnode = lst-&gt;front;
    while (prevnode-&gt;next &amp;&amp; i != prevnode-&gt;next-&gt;item) {
        prevnode = prevnode-&gt;next;
    }
    if (prevnode-&gt;next == NULL) return false;
    struct llnode *backup = prevnode-&gt;next;
    prevnode-&gt;next = prevnode-&gt;next-&gt;next;
    free(backup);
    return true;
}
</code></pre>

<h4 id="revisiting-the-wrapper-approach"><a name="user-content-revisiting-the-wrapper-approach" href="#revisiting-the-wrapper-approach" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Revisiting the wrapper approach</h4>
<p>Throughout these slides we have used a <strong>wrapper</strong> strategy, where we wrap the link to the first node inside of another structure (<code>llist</code>).</p>
<p>Some of the advantages of this strategy are:<br />
<em>   cleaner function interfaces<br />
</em>   reduced need for double pointers<br />
<em>   reinforces the imperative paradigm<br />
</em>   less susceptible to misuse and list corruption</p>
<p>The disadvantages of the wrapper approach include:<br />
<em>   slightly more awkward recursive implementations<br />
</em>   extra &ldquo;special case&rdquo; code around the first term</p>
<p>However, there is one more significant advantage of the wrapper approach: <strong>additional information</strong> can be stored in the list structure.</p>
<p>Consider that we are writing an application where the <code>length</code> of a linked list will be queried often.</p>
<p>Typically, finding the length of a linked list is $O(n)$.</p>
<p>However, we can store (or &ldquo;cache&rdquo;) the length in the wrapper structure, so the length can be retrieved in $O(1)$ time.</p>
<pre><code class="C">struct llist {
    struct llnode *front;
    int length;
};
</code></pre>

<p>Naturally, other list functions would have to update the <code>length</code> as necessary<br />
<em>   <code>list_create</code> would initialize length to zero<br />
</em>   <code>add_front</code> would increment length<br />
*   <code>remove_front</code> would decrement length</p>
<h4 id="data-integrity"><a name="user-content-data-integrity" href="#data-integrity" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Data integrity</h4>
<p>The introduction of the <code>length</code> field to the linked list may seem like a great idea to improve efficiency.</p>
<p>However, it introduces new ways that the structure can be corrupted. What if the <code>lenth</code> field does not accurately reflect the true length?</p>
<p>For example, imagine that someone implements the <code>remove_item</code> function, but forgets to update the <code>length</code> field?</p>
<p>Or a naive coder may think that the following statement removes all of the codes from the list.</p>
<pre><code class="C">lst-&gt;length = 0;
</code></pre>

<p><strong>Whenever the same information is stored in more than one way, it is susceptible to integrity (consistency) issues.</strong></p>
<p>Advanced testing methods can often find these types of errors, but you must exercise caution.</p>
<p>If data integrity is an issue, it is often better to repackage the data structure as a separate ADT module and only provide interface functions to the client.</p>
<p>This is an example of <strong>security</strong> (protecting the client from themselves).</p>
<h4 id="queue-adt"><a name="user-content-queue-adt" href="#queue-adt" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Queue ADT</h4>
<p>A queue is like a &ldquo;lineup&rdquo;, where new items go to the &ldquo;back&rdquo; of the line, and the items are removed from the &ldquo;front&rdquo; of the line. While a stack is LIFO, a queue is FIFO (first in, first out).</p>
<p>Typical queue ADT operations:<br />
<em>   <code>add_back</code>: adds an item to the end of the queue<br />
</em>   <code>remove_front</code>: removes the item at the front of the queue<br />
<em>   <code>front</code>: returns the item at the front<br />
</em>   <code>is_empty</code>: determines if the queue is empty</p>
<p>A Stack ADT can be easily implemented using a dynamic array or with a linked list.</p>
<p>When it is possible to implement a Queue ADT with a dynamic array, the implementation is a bit tricky. Queues are typically implemented with linked lists.</p>
<p>The only concern is that an add_back operation is normally $O(n)$.</p>
<p>However, if we maintain a pointer to the back (last element) of the list, in addition to a pointer to the front of the list, we can implement <code>add_back</code> in $O(1)$.</p>
<blockquote>
<p>Maintaining a <code>back</code> pointer is a popular modification to a traditional linked list, and another reason to use a wrapper.</p>
</blockquote>
<pre><code class="C">// queue.h
// all operations are O(1) (except destroy)

struct queue;

struct queue *queue_create(void);

void queue_add_back(int i, struct queue *q);

int queue_remove_front(struct queue *q);

int queue_front(struct queue *q);

bool queue_is_empty(struct queue *q);

void queue_destroy(struct queue *q);
</code></pre>

<pre><code class="C">// queue.c (IMPLEMENTATION)

struct llnode {
    int item;
    struct llnode *next;
};

struct queue {
    struct llnode *front;
    struct llnode *back;
};

struct queue *queue_create(void) {
    struct queue *q = malloc(sizeof(struct queue));
    q-&gt;front = NULL;
    q-&gt;back = NULL;
    return q;
}

void queue_add_back(int i, struct queue *q) {
    struct llnode *node = malloc(sizeof(struct llnode));
    node-&gt;item = i;
    node-&gt;next = NULL;
    if (q-&gt;front == NULL) {
        q-&gt;front = node;
    } else {
        q-&gt;back-&gt;next = node;
    }
    q-&gt;back = node;
}

int queue_remove_front (struct queue *q) {
    assert(q-&gt;front);
    int retval = q-&gt;front-&gt;item;
    struct llnode *backup = q-&gt;front;
    q-&gt;front = q-&gt;front-&gt;next;
    free(backup);
    if (q-&gt;front == NULL) q-&gt;back = NULL;
    return retval;
}

int queue_front(struct queue *q) {
    assert(q-&gt;front);
    return q-&gt;front-&gt;item;
}
bool queue_is_empty(struct queue *q) {
    return q-&gt;front == NULL;
}
void queue_destroy(struct queue *q) {
    while (!queue_is_empty(q)) {
        queue_remove_front(q);
    }
    free(q);
}
</code></pre>

<h4 id="node-augmentation-strategy"><a name="user-content-node-augmentation-strategy" href="#node-augmentation-strategy" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Node augmentation strategy</h4>
<p>In an <strong>node augmentation strategy</strong>, each node is augmented to include additional information about the node or the structure.</p>
<p>For example, a <strong>dictionary</strong> node can contain both a <em>key</em> (item) and a corresponding <em>value</em>.</p>
<p>Or for a <strong>priority queue</strong>, each node can additionally store the priority of the item.</p>
<p>The most common node augmentation for a linked list is to create a <strong>double linked list</strong>, where each node also contains a pointer to the previous node. When combined with <code>back</code> pointer in a wrapper, a double linked list can add or remove from the front and back in $O(1)$ time.</p>
<p><img alt="double linked list" src="http://tonyli.tk/notes/cs136/sec11pg43.PNG" /></p>
<p>Many programming environments provide a Double-Ended Queue (dequeue or deque) ADT, which can be used as a stack or a Queue ADT.</p>
<h4 id="trees"><a name="user-content-trees" href="#trees" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Trees</h4>
<p>At the implementation level, <strong>trees</strong> are very similar to linked lists.</p>
<p>Each node can <em>link</em> to more than one node.</p>
<p><img alt="tree" src="http://tonyli.tk/notes/cs136/sec11pg44.PNG" /></p>
<h4 id="tree-terminology"><a name="user-content-tree-terminology" href="#tree-terminology" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Tree terminology</h4>
<ul>
<li>the <strong>root node</strong> has no <strong>parent</strong></li>
<li>all other nodes have exactly one parent</li>
<li>nodes can have multiple <strong>children</strong></li>
<li>in a <strong>binary tree</strong>, each node has at most two children</li>
<li>a <strong>leaf node</strong> has no children</li>
<li>the <strong>height</strong> of a tree is the maximum possible number of nodes from the root to a leaf (inclusive)B</li>
<li>the height of an empty tree is zero</li>
</ul>
<h4 id="binary-search-trees-bsts"><a name="user-content-binary-search-trees-bsts" href="#binary-search-trees-bsts" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Binary Search Trees (BSTs)</h4>
<p>Binary Search Tree (BST) enforce the <strong>ordering property</strong>: for every node with an item $i$, all items in the left child subtree are less than $i$, and all items in the right child subtree are greater than $i$.</p>
<p><img alt="tree" src="http://tonyli.tk/notes/cs136/sec11pg44.PNG" /></p>
<h4 id="mixing-paradigms_1"><a name="user-content-mixing-paradigms_1" href="#mixing-paradigms_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Mixing paradigms</h4>
<p>As with linked lists, we have to be careful not to mix functional and imperative paradigms, especially when adding nodes. The following example visualizes what Racket produces when a node (45) is added to the BST illustrated earlier.</p>
<p><img alt="racket tree" src="http://tonyli.tk/notes/cs136/sec11pg47.PNG" /></p>
<p>Our BST node (<code>bstnode</code>) is very similar to our linked list node definition.</p>
<pre><code class="C">struct bstnode {
    int item;
    struct bstnode *left;
    struct bstnode *right;
};

struct bst {
    struct bstnode *root;
};
</code></pre>

<p>As with linked lists, we will need a function to create a new BST.</p>
<pre><code class="C">// bst_create() creates a new BST
// effects: allocates memory: call bst_destroy
struct bst *bst_create(void) {
    struct bst *t = malloc(sizeof(struct bst));
    t-&gt;root = NULL;
    return t;
}
</code></pre>

<p>Before writing code to insert a new node, first we write a helper to create a new leaf node.</p>
<pre><code class="C">struct bstnode *new_leaf(int i) {
    struct bstnode *leaf = malloc(sizeof(struct bstnode));
    leaf-&gt;item = i;
    leaf-&gt;left = NULL;
    leaf-&gt;right = NULL;
    return leaf;
}
</code></pre>

<p>As with lists, we can write tree functions recursively or iteratively.</p>
<p>Wee need to <strong>recurse</strong> on nodes. This code emulates a functional approach, but is careful to only allocate one new (leaf) node.</p>
<pre><code class="C">struct bstnode *insert_bstnode(int i, struct bstnode *node) {
    if (node == NULL) {
        node = new_leaf(i);
    } else if (i &lt; node-&gt;item) {
        node-&gt;left = insert_bstnode(i, node-&gt;left);
    } else if (i &gt; node-&gt;item) {
        node-&gt;right = insert_bstnode(i, node-&gt;right);
    } // else do nothing, as item already exists.
    return node;
}

void bst_insert(int i, struct bst *t) {
    t-&gt;root = insert_bstnode(i, t-&gt;root);
}
</code></pre>

<p>The iterative version is similar to the linked list approach.</p>
<pre><code class="C">void bst_insert(int i, struct bst *t) {
    struct bstnode *curnode = t-&gt;root;
    struct bstnode *prevnode = NULL;
    while (curnode) {
        if (curnode-&gt;item == i) return;
        prevnode = curnode;
        if (i &lt; curnode-&gt;item) {
            curnode = curnode-&gt;left;
        } else {
            curnode = curnode-&gt;right;
        }
    }
    if (prevnode == NULL) { // tree was empty
        t-&gt;root = new_leaf(i);
    } else if (i &lt; prevnode-&gt;item) {
        prevnode-&gt;left = new_leaf(i);
    } else {
        prevnode-&gt;right = new_leaf(i);
    }
}
</code></pre>

<h4 id="trees-and-efficiency"><a name="user-content-trees-and-efficiency" href="#trees-and-efficiency" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Trees and efficiency</h4>
<p>What is the efficiency of <code>bst_insert</code>?</p>
<p>The worst case is when the tree is <strong>unbalanced</strong>, and every node in the tree must be visited.</p>
<p><img alt="unbalanced" src="http://tonyli.tk/notes/cs136/sec11pg54.PNG" /></p>
<p>In this example, the running time of <code>bst_insert</code> is $O(n)$, where $n$ is the number of nodes in the tree.</p>
<p>The running time of <code>bst_insert</code> is $O(h)$: it depends more on the height of the tree (h) than the size of the tree (n),</p>
<p>The definition of a <strong>balanced tree</strong> is a tree where the height (h) is $O(\log n)$.</p>
<p>Conversely, an unbalanced tree is a tree with a height that is not $O(\log n)$. The height of an unbalanced tree is $O(n)$.</p>
<p>Using the <code>bst_insert</code> function we provided, inserting the nodes in sorted order creates an unbalanced tree.</p>
<p>With a <strong>balanced</strong> tree, the running time of standard tree functions (e.g. <code>insert</code>, <code>remove</code>, <code>search</code>) are all $O(\log n)$.</p>
<p>With an <strong>unbalanced</strong> tree, the running time of each function is $O(h)$.</p>
<p>A <strong>self-balancing tree</strong> &ldquo;re-arranges&rdquo; the nodes to ensure that tree is always balanced.</p>
<p>With a good self-balancing implementation, all standard tree functions preserve the balance of the tree and have an $O(\log n)$ running time.</p>
<h4 id="size-node-augmentation"><a name="user-content-size-node-augmentation" href="#size-node-augmentation" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Size node augmentation</h4>
<p>A popular tree <strong>node augmentation</strong> is to store in each node the size of its subtree.</p>
<pre><code class="C">struct bstnode {
    int item;
    struct bstnode *left;
    struct bstnode *right;
    int size;d
};
</code></pre>

<p>This augmentation allows us to retrieve the size of the tree in $O(1)$ time.</p>
<p>It also allows us to implement a <code>select</code> function in $O(h)$ time.</p>
<p><code>select(k)</code> finds the k-th smallest item in the tree.</p>
<p><img alt="size node augmentation" src="http://tonyli.tk/notes/cs136/sec11pg58.PNG" /></p>
<p>The following code illustrate how to select the k-th item in a BST with a size node augmentation.</p>
<pre><code class="C">int select_node(int k, struct bstnode *node) {
    assert(node &amp;&amp; 0 &lt;= k &amp;&amp; k &lt; node-&gt;size);
    int left_size = 0;
    if (node-&gt;left) left_size = node-&gt;left-&gt;size;
    if (k &lt; left_size) return select_node(k, node-&gt;left);
    if (k == left_size) return node-&gt;item;
    return select_node(k - left_size - 1, node-&gt;right);
}

int bst_select(int k, struct bst *t) {
    return select_node(k, t-&gt;root);
}
</code></pre>

<p><code>select(0, t)</code> finds the smallest item in the tree.</p>
<h4 id="array-based-trees"><a name="user-content-array-based-trees" href="#array-based-trees" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Array-based trees</h4>
<p>For some types of trees, it is possible to use an <strong>array</strong> to store a tree.<br />
<em>   the root is stored at <code>a[0]</code><br />
</em>   for the node at <code>a[i]</code>, its <code>left</code> is stored at <code>a[2*i+1]</code><br />
<em>   its <code>right</code> is stored at <code>a[2*i+2]</code><br />
</em>   its <code>parent</code> is stored at <code>a[(i-1)/2]</code><br />
<em>   a special </em>sentinel value<em> can be used to indicate an empty node<br />
</em>   a tree of height $h$ requires an array of size $2^h-1$<br />
(a dynamic array can be realloc&rsquo;d as the tree height grows)</p>
<p><img alt="array based tree" src="http://tonyli.tk/notes/cs136/sec11pg61.PNG" /></p>
<blockquote>
<p>Array-based trees are often used to implement complete trees,<br />
where there are no empty nodes, and every level of the tree is<br />
filled (except the bottom).<br />
The heap data structure (not the section of memory) is often<br />
implemented as a complete tree in an array.<br />
For self-balancing trees, the self-balancing (e.g., rotations) is<br />
often more awkward in the array notation. However, arrays work<br />
well with lazy rebalancing, where a rebalancing occurs<br />
infrequently (i.e., when a large inbalance is detected). The tree<br />
can be rebalanced in $O(n)$ time, typically achieving amortized<br />
$O(log n)$ operations.</p>
</blockquote>
<h4 id="dictionary-adt-revisited"><a name="user-content-dictionary-adt-revisited" href="#dictionary-adt-revisited" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Dictionary ADT (revisited)</h4>
<p>The dictionary ADT (also called a map, associative array, or symbol<br />
table), is a collection of <strong>pairs</strong> of <strong>keys</strong> and <strong>values</strong>. Each key is unique and has a corresponding value, but more than one key may have the same value.</p>
<p>Typical dictionary ADT operations:<br />
<em>   <strong>look up</strong>: for a given key, retrieve the corresponding value or &ldquo;not found&rdquo;<br />
</em>   <strong>insert</strong>: adds a new key/value pair (or replaces the value of an existing key)<br />
*   <strong>remove</strong>: deletes a key and its value</p>
<p>In the following example, we implement a Dictionary ADT using a BST data structure.</p>
<pre><code class="C">// dictionary.h

struct dictionary;
struct dictionary *dict_create(void);
void dict_insert(int key, const char *val, struct dictionary *d);
const char *dict_lookup(int key, struct dictionary *d);
void dict_remove(int key, struct dictionary *d);
void dict_destroy(struct dictionary *d);
</code></pre>

<p>Using the same <code>bstnode</code> structure, we augment each node by adding an additional <code>value</code> field.</p>
<pre><code class="C">struct bstnode {
    int item; // key
    char *value; // additional value
    struct bstnode *left;
    struct bstnode *right;
};
struct dictionary {
    struct bstnode *root;
};
struct dictionary *dict_create(void) {
    struct dictionary *d = malloc(sizeof(struct dictionary));
    d-&gt;root = NULL;
    return d;
}
</code></pre>

<p>When inserting key/value pairs to the dictionary, we make a copy of the string passed by the client. When removing nodes, we also <code>free</code> the value.</p>
<p>If the client tries to insert a duplicate key, we replace the old value with the new value.</p>
<p>The following recursive implementation of the <code>insert</code> operation is nearly identical to our previous <code>bst_insert</code>. The differences are noted with comments.</p>
<pre><code class="C">struct bstnode *insert_bstnode(int key, const char *val, struct bstnode *node) {
    if (node == NULL) {
        node = malloc(sizeof(struct bstnode));
        node-&gt;item = key;
        node-&gt;value = my_strdup(val); // make copy
        node-&gt;left = NULL;
        node-&gt;right = NULL;
    } else if (key &lt; node-&gt;item) {
        node-&gt;left = insert_bstnode(key, val, node-&gt;left);
    } else if (key &gt; node-&gt;item) {
        node-&gt;right = insert_bstnode(key, val, node-&gt;right);
    } else { // key == node-&gt;item: must replace the old value
        free(node-&gt;value);
        node-&gt;value = my_strdup(val);
    }
    return node;
}

void dict_insert(int key, const char *val, struct dictionary *d) {
    d-&gt;root = insert_bstnode(key, val, d-&gt;root);
}
</code></pre>

<p>This implementation of the <code>lookup</code> operation will return <code>NULL</code> if unsuccessful.</p>
<pre><code class="C">const char *dict_lookup(int key, struct dictionary *d) {
    struct bstnode *curnode = d-&gt;root;
    while (curnode) {
        if (curnode-&gt;item == key) {
            return curnode-&gt;value;
        }
        if (key &lt; curnode-&gt;item) {
            curnode = curnode-&gt;left;
        } else {
            curnode = curnode-&gt;right;
        }
    }
    return NULL;
}
</code></pre>

<p>There are several different ways of removing a node from a BST.</p>
<p>We implement <code>remove</code> with the following strategy:<br />
<em>   If the node with the key (&ldquo;key node&rdquo;) is a leaf, we remove it.<br />
</em>   If one child of the key node is empty (<code>NULL</code>), the other child is &ldquo;promoted&rdquo; to replace the key node.<br />
*   Otherwise, we find the node with the next largest key (&ldquo;next node&rdquo;) in the tree (i.e. the smallest key in the right subtree). We replace the key/value of the key node with the key/value of the next node, and then remove the next node from the right subtree.</p>
<pre><code class="C">void dict_remove(int key, struct dictionary *d) {
    d-&gt;root = remove_bstnode(key, d-&gt;root);
}

struct bstnode *remove_bstnode(int key, struct bstnode *node) {
    // key did not exist:
    if (node == NULL) return NULL;

    // search for the node that contains the key
    if (key &lt; node-&gt;item) {
        node-&gt;left = remove_bstnode(key, node-&gt;left);
    } else if (key &gt; node-&gt;item) {
        node-&gt;right = remove_bstnode(key, node-&gt;right);
    } else if (node-&gt;left == NULL) {
        struct bstnode *backup = node-&gt;right;
        free(node-&gt;value);
        free(node);
        return backup;
    } else if (node-&gt;right == NULL) {
        struct bstnode *backup = node-&gt;left;
        free(node-&gt;value);
        free(node);
        return backup;
    } else {
        // find the next largest key
        struct bstnode *next = node-&gt;right;
        while (next-&gt;left) {
            next = next-&gt;left;
        }

        // remove the old value
        free(node-&gt;value);

        // replace the key/value of this node
        node-&gt;item = next-&gt;item;
        node-&gt;value = my_strdup(next-&gt;value);

        // remove the next largest key
        node-&gt;right = remove_bstnode(next-&gt;item, node-&gt;right);
    }

    return node;
}
</code></pre>

<p>Finally, the recursive <code>destroy</code> operation frees the children and the (string) value before itself.</p>
<pre><code class="C">void free_bstnode(struct bstnode *node) {
    if (node) {
        free_bstnode(node-&gt;left);
        free_bstnode(node-&gt;right);
        free(node-&gt;value);
        free(node);
    }
}
void dict_destroy(struct dictionary *d) {
    free_bstnode(d-&gt;root);
    free(d);
}
</code></pre>

<h4 id="graphs"><a name="user-content-graphs" href="#graphs" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Graphs</h4>
<p>Linked lists and trees can be thought of as special cases of a<br />
<strong>graph</strong> data structure.</p>
<p><img alt="graphs" src="http://tonyli.tk/notes/cs136/sec11pg74.PNG" /></p>
<p>Graphs link <strong>nodes</strong> with <strong>edges</strong>. Graphs may be undirected (i) or<br />
directed (ii), allow cycles (ii) or be acyclic (iii), and have labeled<br />
edges (iv) or unlabeled edges (iii).</p>
<h4 id="goals-of-this-section"><a name="user-content-goals-of-this-section" href="#goals-of-this-section" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Goals of this section</h4>
<p>At the end of this section, you should be able to:<br />
<em>   use the new linked list and tree terminology introduced<br />
</em>   use linked lists and trees with a recursive or iterative approach<br />
<em>   use wrapper structures and node augmentations to improve<br />
efficiency<br />
</em>   explain why an unbalanced tree can affect the efficiency of tree</p></article></body></html>